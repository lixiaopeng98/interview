package com.interview.demo.redis.transaction;

public class TransactionRedis {

    /**
     * Redis 事务
     *
     * Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，
     * 然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，
     * 它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。
     * 在 Redis 中，事务总是具有原子性（Atomicity)、一致性(Consistency)和隔离性（Isolation），
     * 并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）
     *
     * MULTI 开启事务
     * EXEC 相等于commit 把事务提交给服务器
     * WATCH 乐观锁 他可以在ESEC 命令执行之前，监视任意数量的数据库键，并在exec 命令执行时，检查被监视的键是否至少有一个已经被
     *              修改过了，如果是的话买服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。
     */

    /**
     * 1. MULTI 从非事务状态 切换至 事务状态
     * 2. 命令入队
     *      如果客户端 发送命令包含：EXEC DISCARD WATCH MULTI 会立即执行
     *      其余命令会放入一个事务队列里面，然后返回 queued
     *      队列 按照先进先出（FIFO）的方式保存入队
     * 3. EXEC 执行事务
     */

    /**
     * WATCH 乐观锁
     * 1. 底层用字典存储 被监视的数据
     * 2. 所有对数据库进行修改的命令， 比如SET， LPUSH，SADD，ZREM，DEL，等等，在执行之后都会检查是否有客户端正在监视
     *      如果有会将监视REDIS_DIRTY_CAS标识打开，标识安全性已经被破坏
     * 3. 判断事务是否安全
     *      在服务器收到客户端发来的EXEC命令时，服务器会根据这个客户端是否打开了CAS标识来决定是否执行事务：
     *       如果打开了 服务器会拒绝执行客户端提交的事务，没有被打开 判断是安全的服务器将执行客户端提交的事务
     */
}
