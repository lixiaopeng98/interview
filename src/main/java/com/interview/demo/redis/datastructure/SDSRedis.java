package com.interview.demo.redis.datastructure;

public class SDSRedis {

    /**
     * redis 的 SDS
     *
     *  int len; -- 已使用空间的大小
     *  int free; -- 没有使用的空间大小
     *  char buf[]; -- 实际存储数据 char数组
     *
     *
     * 1. 跟C语言的字符串有区别
     * 2. 获取长度为O(1)
     *      因为 sds 对数据的长度有记录 所以直接就是 O(1)
     * 3. 杜绝缓冲区溢出
     *      当sds api 需要对sds进行修改的时候，api会先检查sds的空间是否满足修改的需求，如果不满足的话，
     *      api会自动将sds的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用sds既不需要
     *      手动修改sds的空间大小，也不会出现前面所说的缓冲区溢出问题
     * 4. 减少修改字符串时带来的内存重分配次数
     *      空间预分配: 优化SDS的字符串增长操作,当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候
     *                 程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间
     *          空间预分配算法:
     *              修改完后len的长度 如果没有超过1M free.length = len.length
     *                  buf.length = free.length + len.length + 1byte
     *              如果超过1M  free.length = 1M
     *                  buf.length = 1M + len.length + 1byte
     *      惰性空间释放: 当SDS的api需要缩短 SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节
     *                  而是使用free属性将这些字节的数量记录起来，并等待将来使用
     * 5. 二进制安全 所有sds api都会以处理二进制的方式来处理sds存放在buf数组里的数据，程序不会对其中的数据做任何限制、
     *             过滤、或者假设、数据在写入时是什么样的，它被读取时就是什么样
     * 6. 兼容部分C语言 字符串函数
     *          遵循C语言 字符串的惯例，使SDS可以重用一部分c语言的函数
     */
    /**
     * C语言 字符串和SDS之间的区别
     * C字符串                               |   SDS
     * 获取字符串长度的复杂度为O(N)              | 获取字符串长度的复杂度为O(1)
     * API是不安全的，可能会造成缓冲区溢出        | API是安全的，不会造成缓冲区溢出
     * 修改字符串长度N次必然需要执行N次内存重分配   | 修改字符串长度N次最多需要执行N次内存重分配
     * 只能保存文本数据                        | 可以保存文本或者二进制数据
     * 可以使用所有<string.h>库中的函数         | 可以使用一部分<string.h>库中的函数
     *
     */
}
